package ru.clevertec.cachestarter.exploitation;

import lombok.RequiredArgsConstructor;
import org.springframework.util.ReflectionUtils;
import ru.clevertec.cachestarter.annotation.CacheMethod;
import ru.clevertec.cachestarter.annotation.Caching;
import ru.clevertec.cachestarter.cache.Cache;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.stream.IntStream;

/**
 * The class is responsible for caching operation
 */
@RequiredArgsConstructor
public class CacheManager {

    private final Cache<Object, Object> cache;
    private final String SEPARATOR_KEY = "\\.";

    public Cache<Object, Object> getCache() {
        return cache;
    }

    /**
     * Return the result of the method execution, or an object from the cache, if available
     *
     * @param methodImpl implementation
     * @param method     interface
     * @param bean       the object whose method is being executed
     * @param objects    method parameters
     * @return the result of the method execution, or an object from the cache, if available
     * @throws Throwable if something goes wrong
     */

    public Object getResult(Method methodImpl,
                            Method method,
                            Object bean,
                            Object[] objects) throws Throwable {
        Caching caching = methodImpl.getAnnotation(Caching.class);
        String keyName = caching.key();
        String[] split = keyName.split(SEPARATOR_KEY);
        Object result = null;
        Object keyValue;
        KeyContent key;
        boolean isExtract = caching.method() == CacheMethod.EXTRACT;
        if (caching.incoming() && !isExtract) {
            key = getKeyContent(methodImpl, method, objects);
        } else {
            result = invoke(method, bean, objects);
            if (isExtract) {
                executeExtract(result, methodImpl, keyName, split);
            } else {
                keyValue = getKeyValue(result, split);
                key = new KeyContent(keyName, keyValue, methodImpl.getReturnType());
                cache.put(key, result);
            }
            return result;
        }
        switch (caching.method()) {
            case GET -> {
                result = cache.get(key);
                if (Objects.isNull(result)) {
                    result = invoke(method, bean, objects);
                    cache.put(key, result);
                }
            }
            case CHANGE -> {
                result = invoke(method, bean, objects);
                cache.put(key, result);
            }
            case DELETE -> {
                result = invoke(method, bean, objects);
                cache.delete(key);
            }
        }
        return result;
    }

    private Object invoke(Method method, Object bean, Object[] objects) throws Throwable {
        try {
            return method.invoke(bean, objects);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    private KeyContent getKeyContent(Method methodImpl, Method method, Object[] objects) {
        String keyName = methodImpl.getAnnotation(Caching.class).key();
        String[] split = keyName.split(SEPARATOR_KEY);
        Object arg = IntStream.range(0, method.getParameters().length)
                .filter(i -> methodImpl.getParameters()[i].getName().equals(split[0]))
                .mapToObj(i -> objects[i]).findAny().get();
        Object keyValue = getKeyValue(arg, Arrays.copyOfRange(split, 1, split.length));
        return new KeyContent(keyName, keyValue, methodImpl.getReturnType());
    }

    private void executeExtract(Object result,
                                Method method,
                                String keyName,
                                String[] split) {
        Iterator<?> iterator = ((Iterable<?>) result).iterator();
        List<Object> returnedObjects = new ArrayList<>();
        while (iterator.hasNext()) {
            returnedObjects.add(iterator.next());
        }
        int sizeResult = returnedObjects.size();
        int capacity = cache.getCapacity();
        Type type = ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0];
        if (sizeResult > capacity) {
            returnedObjects.stream().skip(sizeResult - capacity).forEach(o ->
                    cache.put(new KeyContent(keyName, getKeyValue(o, split), (Class<?>) type), o));
        } else {
            returnedObjects.forEach(o ->
                    cache.put(new KeyContent(keyName, getKeyValue(o, split), (Class<?>) type), o));
        }
    }

    private Object getKeyValue(Object arg, String[] split) throws RuntimeException {
        if (split.length > 0) {
            Field field;
            try {
                field = arg.getClass().getDeclaredField(split[0]);
            } catch (NoSuchFieldException e) {
                throw new RuntimeException(e);
            }
            field.setAccessible(true);
            Object nestedArg = ReflectionUtils.getField(field, arg);
            String[] newSplit = Arrays.copyOfRange(split, 1, split.length);
            arg = getKeyValue(nestedArg, newSplit);
        }
        return arg;
    }

}