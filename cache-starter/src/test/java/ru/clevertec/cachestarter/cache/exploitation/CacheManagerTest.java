package ru.clevertec.cachestarter.cache.exploitation;

import jakarta.annotation.PostConstruct;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import ru.clevertec.cachestarter.cache.impl.LFUCache;
import ru.clevertec.cachestarter.config.CacheAutoConfiguration;
import ru.clevertec.cachestarter.data.*;
import ru.clevertec.cachestarter.exploitation.CacheManager;
import ru.clevertec.cachestarter.exploitation.KeyContent;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertSame;

@SpringBootTest(classes = {CacheAutoConfiguration.class, ServiceImpl.class},
        properties = "ru.clevertec.cache.enabled=true")
class CacheManagerTest {

    @Autowired
    private CacheManager cacheManager;

    @Autowired
    Service service;

    private LFUCache<Object, Object> cache;
    private Map<Integer, Entity> entities;

    @PostConstruct
    void init() {
        cache = (LFUCache<Object, Object>) cacheManager.getCache();
        entities = service.getEntities();
        IntStream.range(1, 7).forEach(i ->
                entities.put(i, Entity.builder().arg0(i).arg1(new Entity.Nested(i)).build()));
    }

    @BeforeEach
    void setUp() {
        cache.clear();
    }

    @Nested
    class ShouldAddToCacheWithProperties {

        @Test
        void methodEXRACTWithExceedCacheCapacity() {
            int quantity = entities.size();
            List<Integer> expectedId = entities.values().stream()
                    .map(Entity::getArg0).toList().subList(1, quantity);
            service.methodEXTRACT(quantity);
            List<Integer> actualId = cache.getKeyValueMap().values().stream()
                    .map(o -> ((EntityDto) o).arg0()).sorted().toList();
            assertThat(actualId).isEqualTo(expectedId);
        }

        @Test
        void methodEXRACTWithoutExceedCacheCapacity() {
            List<Entity> expected = entities.values().stream().toList().subList(0, 3);
            service.methodEXTRACT(3);
            assertThat(cache.getKeyValueMap().size()).isEqualTo(expected.size());
        }

        @Test
        void methodGET() {
            Entity expected = entities.get(1);
            Integer arg0 = expected.getArg0();
            service.methodGET(arg0);
            var key = new KeyContent("arg0", arg0, EntityDto.class);
            EntityDto actual = (EntityDto) cache.getKeyValueMap().get(key);
            assertThat(actual.arg0()).isEqualTo(expected.getArg0());
        }

        @Test
        void methodCHANGE() {
            int arg0 = 1;
            Entity expected = entities.get(arg0);
            service.methodCHANGE(arg0);
            var key = new KeyContent("arg0", arg0, EntityDto.class);
            EntityDto actual = (EntityDto) cache.getKeyValueMap().get(key);
            assertThat(actual.arg0()).isEqualTo(expected.getArg0());
        }

        @Test
        void methodDELETE() {
            int arg0 = 1;
            var key = new KeyContent("arg0", arg0, EntityDto.class);
            cache.put(key, new EntityDto(arg0, null));
            service.methodDELETE(arg0);
            Object actual = cache.getKeyValueMap().get(key);
            assertThat(actual).isNull();
        }

        @Test
        void incomingFALSE() {
            int arg0 = 1;
            service.incomingFALSE(arg0);
            var key = new KeyContent("arg0", arg0, EntityDto.class);
            EntityDto actual = (EntityDto) cache.getKeyValueMap().get(key);
            assertThat(actual.arg0()).isEqualTo(arg0);
        }

        @Test
        void nestedKeyIncomingTRUE() {
            int arg0 = 1;
            Entity entity = Entity.builder().arg0(arg0).build();
            service.nestedKeyIncomingTRUE(entity);
            var key = new KeyContent("arg0.arg0", arg0, EntityDto.class);
            EntityDto actual = (EntityDto) cache.getKeyValueMap().get(key);
            assertThat(actual.arg0()).isEqualTo(arg0);
        }

        @Test
        void nestedKeyIncomingFALSE() {
            int arg0 = 1;
            service.nestedKeyIncomingFALSE(arg0);
            var key = new KeyContent("arg2.arg0", arg0, EntityDto.class);
            EntityDto actual = (EntityDto) cache.getKeyValueMap().get(key);
            assertThat(actual.arg0()).isEqualTo(arg0);
        }

    }

    @Nested
    class ShouldReturnFromCache {

        @Test
        void nestedKeyIncomingFALSE() {
            int arg0 = 1;
            EntityDto beforeCache = service.methodGET(arg0);
            EntityDto afterCache = service.methodGET(arg0);
            assertAll(
                    () -> assertSame(beforeCache, afterCache),
                    () -> assertThat(beforeCache).isEqualTo(afterCache));
        }

    }

}